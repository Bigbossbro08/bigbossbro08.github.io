{
  "projects": [
    {
      "id": "horse-archery-in-alsv4",
      "title": "Horse Archery Integration within ALSV4",
      "shortDescription": "My implementation of Horse Archery after I implemented Horse mounting system",
      "contentMarkdown": "In past I added horse mouting system. For 360 animation, tried to be creative and added auto switching of hands in horse archery. All of it is done through the framework of ALSV4 made for Unreal Engine \n\n<div class=\"video-container\">\n  <iframe src=\"https://www.youtube.com/embed/ZLRUUHrdzJA\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>"
    },
    {
      "id": "new-overlays-to-alsv4",
      "title": "Adding new Overlays to ALSV4",
      "shortDescription": "My experimental work on adding ALSV4",
      "contentMarkdown": "Nothing much. Here I am showing my small experimental work where I added new poses using ALSV4. Even added some other unique features to it.\n\n<div class=\"video-container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/SQsvB1hEVMA?si=khHGEjaWx6-GAGRX\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n</div>"
    },
    {
      "id": "3d-works",
      "title": "Some of my 3D hobbies I did in past",
      "shortDescription": "...",
      "contentMarkdown": "As a hobby and to have some ideas about how 3D assets work for game engines, did some experimental 3D modelling. Did an eastern/mongolian style armor which fits Unreal's Mannequin skeleton in past.\n\n![Mongol Spear](https://cdnb.artstation.com/p/assets/images/images/035/977/523/large/bigbossbro08-mongolianspearrender.jpg?1616422644)\n\n![Mongol Mace](https://cdnb.artstation.com/p/assets/images/images/036/016/451/large/bigbossbro08-mongolianmace.jpg?1616513920)\n\n![Mongol Sword](https://cdnb.artstation.com/p/assets/images/images/035/971/967/large/bigbossbro08-mongolianswordrender.jpg?1616411333)\n\n![Mongol/Eastern Soldier Body](https://cdnb.artstation.com/p/assets/images/images/035/976/279/large/bigbossbro08-mongolianarmorrender.jpg?1616420354)"
    },
    {
      "id": "shader-trick-to-have-unique-emblem",
      "title": "Shader trick that I did to make unique emblem",
      "shortDescription": "...",
      "contentMarkdown": "I made this simple shader trick in past. Where I used 3 rgb layer to split the color and then render unique by multiplying it with my own value I want. Altho some better way do exist.\n<div class=\"video-container\">\n  <iframe src=\"https://cdn.artstation.com/p/video_sources/000/320/769/projecthorde-samplescene-pc-mac-linux-standalone-unity-2020.mp4\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>"
    },
    {
      "id": "my-experimental-approach-to-expand-rts-mechanics",
      "title": "Experimental gameplay mechanics behavior for RTS games like Age Of Empires II",
      "shortDescription": "Here's my experiment about how its possible to have more mechanics AOE2 style RTS game. As in units on top of wall or ships. Even unit movement during ship.",
      "contentMarkdown": "Here's my experiment about how its possible to have more mechanics AOE2 style RTS game. As in units on top of wall or ships. Even unit movement during ship. Also seamlessly to have units in and unboard them somewhere. I'll write more about them soon...\n<div class=\"video-container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/cb8yls7U-dY?si=iPCKVb-vUovfEScA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n</div>"
    },
    {
      "id": "my-approach-to-deterministic-simulation",
      "title": "My approach to implement deterministic lockstep simulation",
      "shortDescription": "Deterministic simulation is one of the primary solution to sync program state seamlessly with no error in game state accuracy at all. Here's a one way to implement this.",
      "contentMarkdown": "Deterministic simulation is one of the primary solution to sync program state seamlessly with no error in game state accuracy at all. Basic rule of deterministic simulation is input must occur at specific state at every machines, random number has to be controlled and should give out same output across, delta time has to be same as in 25 constant FPS for game simulation while visuals are independent from deterministic lockstep.\n\nSo here's how I implemented it in Unity.\n```cpp\n\npublic class DeterministicUpdateManager : MonoBehaviour\n{\n    public static DeterministicUpdateManager Instance { get; private set; }\n\n    public ulong tickCount = 0;\n    public float elapsedTime = 0.0f;\n\n    public int seed = 42;\n\n    private float accumulatedTime = 0f;\n    public const float FixedStep = 1/ 25f; // 60 Hz\n    public DeterministicTimer timer = new DeterministicTimer();\n\n    // **Use a list array instead of a dictionary**\n    private readonly List<IDeterministicUpdate>[] categorizedObjects = new List<IDeterministicUpdate>[64];\n\n    private void Awake()\n    {\n        if (Instance != null && Instance != this)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        Instance = this;\n        DontDestroyOnLoad(gameObject);\n\n        UnityEngine.Random.InitState(seed);\n\n        enabled = false;\n        Time.fixedDeltaTime = FixedStep;\n        Physics.simulationMode = SimulationMode.Script;\n    }\n\n    private void Update()\n    {\n        accumulatedTime += Time.deltaTime;\n        while (accumulatedTime >= FixedStep)\n        {\n            accumulatedTime -= FixedStep;\n\n            // Implement Input Callbacks here\n            InputManager.Instance.DeterministicUpdate(FixedStep, tickCount);\n\n            // Run deterministic game logic here\n            RunDeterministicUpdate(FixedStep, tickCount);\n\n            if (PathfindingManager.Instance.enabled)\n                PathfindingManager.Instance.DeterministicUpdate(FixedStep, tickCount);\n\n            // Step the deterministic timer\n            timer.Update(FixedStep);\n\n            // Manually simulate physics for this step\n            Physics.Simulate(FixedStep);\n\n            elapsedTime += Time.deltaTime;\n            tickCount++;\n        }\n    }\n\n    private void OnDestroy()\n    {\n        // Ensure cleanup when the GameObject is destroyed\n        timer.ClearAllTimers();\n    }\n\n    private void RunDeterministicUpdate(float deltaTime, ulong tickID)\n    {\n        for (int i = 0; i < categorizedObjects.Length; i++)\n        {\n            var objList = categorizedObjects[i];\n            if (objList != null)\n            {\n                for (int j = 0; j < objList.Count; j++)\n                {\n                    objList[j].DeterministicUpdate(deltaTime, tickCount);\n                }\n            }\n        }\n    }\n\n    public void Register<T>(T obj) where T : IDeterministicUpdate\n    {\n        int typeIndex = TypeIndex.GetIndex<T>();\n\n        // Ensure list exists\n        categorizedObjects[typeIndex] ??= new List<IDeterministicUpdate>();\n        categorizedObjects[typeIndex].Add(obj);\n    }\n\n    public void Unregister<T>(T obj) where T : IDeterministicUpdate\n    {\n        int typeIndex = TypeIndex.GetIndex<T>();\n\n        if (categorizedObjects[typeIndex] != null)\n        {\n            categorizedObjects[typeIndex].Remove(obj);\n        }\n    }\n\n    public void Pause()\n    {\n        enabled = false; // Stops Update() from running\n        Debug.LogWarning(\"Deterministic Simulation Paused.\");\n    }\n\n    public void Resume()\n    {\n        enabled = true; // Resumes Update() execution\n        Debug.Log(\"Deterministic Simulation Resumed.\");\n    }\n\n    public bool IsPaused()\n    {\n        return !enabled;\n    }\n}\n```\n\nHere's how it'll be handled. Its pretty similar to how standard FixedTick of Physics works in modern game systems. It even gives us the independence of execution order as well. However our job is not done. We only resolved random number generation and tick control. Input is where it's important. So here's another example how of input can be solved as well. Which is pretty critical and is involved with lag compensation as well across machine.\n\n```\n// InputManager.cs\n\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class InputCommand\n{\n    public ulong frame;      // The frame when this input should execute\n    public int playerID;   // Who sent this input\n    public string action;  // The type of action (e.g., \"Move\", \"Attack\")\n}\n\npublic interface INetworkAdapter\n{\n    void SendCommand(InputCommand command);\n    event Action<InputCommand> OnCommandReceived;\n    void UpdateAdapter();\n    int GetDelay();\n}\n\npublic class InputManager : MonoBehaviour, IDeterministicUpdate\n{\n    public static InputManager Instance;\n    public NetworkAdapter networkAdapter;\n    private Dictionary<ulong, List<InputCommand>> queuedCommands = new Dictionary<ulong, List<InputCommand>>();\n    ulong lastReceivedTick = 0;\n\n    void Awake()\n    {\n        Instance = this;\n    }\n\n    private void OnEnable()\n    {\n        //DeterministicUpdateManager.Instance.Register(this);\n        networkAdapter.OnCommandReceived += QueueInput;\n    }\n\n    private void OnDisable()\n    {\n        //DeterministicUpdateManager.Instance.Unregister(this);\n        networkAdapter.OnCommandReceived -= QueueInput;\n    }\n\n    private void Update()\n    {\n        networkAdapter.UpdateAdapter();\n    }\n\n    public void SendInputCommand(InputCommand command)\n    {\n        command.frame = DeterministicUpdateManager.Instance.tickCount + (ulong)networkAdapter.GetDelay();\n        //QueueInput(command);\n        networkAdapter.SendCommand(command);\n    }\n\n    public void QueueInput(InputCommand command)\n    {\n        if (!queuedCommands.ContainsKey(command.frame))\n            queuedCommands[command.frame] = new List<InputCommand>();\n\n        lastReceivedTick = command.frame;\n\n        //Debug.Log($\"Received and added new command for {command.frame}\");\n        queuedCommands[command.frame].Add(command); \n        \n        if (DeterministicUpdateManager.Instance.IsPaused()) // Check if paused\n        {\n            DeterministicUpdateManager.Instance.Resume(); // Re-enable ticking\n        }\n    }\n\n    private void ProcessCommandsForFrame(ulong frame)\n    {\n        ulong timeoutTicks = (ulong)networkAdapter.GetDelay();\n        //Debug.LogWarning($\"timeout delay: {timeoutTicks}, frame id: {frame} and last received tick: {lastReceivedTick}\");\n        if (!queuedCommands.TryGetValue(frame, out var commands))\n        {\n            if (frame - lastReceivedTick > timeoutTicks)\n            {\n                DeterministicUpdateManager.Instance.Pause(); // Disable ticking\n            }\n            return;\n        }\n\n        foreach (var cmd in commands)\n            ExecuteCommand(cmd);\n        queuedCommands.Remove(frame);\n    }\n\n    private void ExecuteCommand(InputCommand command)\n    {\n        if (command.action != \"KeepAlive\")\n            NativeLogger.Log($\"Executing {command.action} at Frame {command.frame}\");\n        switch (command.action)\n        {\n            case MoveUnitCommand.commandName:\n                {\n                    MoveUnitCommand moveUnitCommand = command as MoveUnitCommand;\n                    moveUnitCommand.Execute();\n                }\n                break;\n            case MoveShipUnitCommand.commandName:\n                {\n                    MoveShipUnitCommand moveShipUnitCommand = command as MoveShipUnitCommand;\n                    moveShipUnitCommand.Execute();\n                }\n                break;\n            case MoveShipToDockCommand.commandName:\n                {\n                    MoveShipToDockCommand moveShipToDockCommand = command as MoveShipToDockCommand;\n                    moveShipToDockCommand.Execute();\n                }\n                break;\n            case MoveUnitsCommand.commandName:\n                {\n                    MoveUnitsCommand moveUnitsCommand = command as MoveUnitsCommand;\n                    moveUnitsCommand.Execute();\n                }\n                break;\n            case AttackUnitCommand.commandName:\n                {\n                    AttackUnitCommand attackUnitCommand = command as AttackUnitCommand;\n                    attackUnitCommand.Execute();\n                }\n                break;\n        }\n    }\n\n    public void DeterministicUpdate(float deltaTime, ulong tickID)\n    {\n        ProcessCommandsForFrame(tickID);\n\n        InputCommand keepAlive = new InputCommand\n        {\n            playerID = -1, // System command\n            action = \"KeepAlive\"\n        };\n        SendInputCommand(keepAlive);\n    }\n}\n\n// SinglePlayerAdapter.cs\n\nusing System.Collections.Generic;\nusing System;\nusing UnityEngine;\n\npublic class SinglePlayerAdapter : NetworkAdapter\n{\n    public int delay = 1;\n\n    private Queue<InputCommand> localQueue = new Queue<InputCommand>();\n\n    public override int GetDelay()\n    {\n        return delay;\n    }\n\n    public override void SendCommand(InputCommand command)\n    {\n        // In singleplayer, execute immediately (or simulate delay)\n        localQueue.Enqueue(command);\n        OnCommandReceived?.Invoke(localQueue.Dequeue());\n\n        //if (command.action == \"KeepAlive\")\n        //    Debug.Log(\"Added and sent command\");\n    }\n\n    public override void UpdateAdapter()\n    {\n        // Empty since we resend input anyway\n    }\n}\n```\nInput system is a bit complex. Because you have to accumulate input data in order. Also it MUST execute in same order. In fixed tick when it prompts for it. Otherwise, you already broke the law of determinism. Also you simply send order and you have to rely on next tick to ensure when it should tick. Below example shows how to make modular actions.\n\nAnother important thing to note that is, you must keep sending input. A small heart beat tick. This way to ensure its in sync with the ticking. If input is failed to receive then it'll simply stop the execution and you wait until all the ticks in future. Currently there are 2 solution to catch up with all machine clients. Either you stop if one fails or you simply continue. The lagging machine simply speeds up the simulation to catch up with rest of the players. Also you add some tick delays too. So that you can accumulate inputs more seamlessly. Thus solving some lags.\n\n```\n\npublic class MoveUnitCommand : InputCommand {\n    public const string commandName = \"Move Unit Command\";\n    public ulong unitID;\n    public Vector3 position;\n\n    public void Execute()\n    {\n        Unit unit = UnitManager.Instance.GetUnit(unitID);\n        if (unit)\n        {\n            MovableUnit movableUnit = (MovableUnit)unit;\n            if (StatComponent.IsUnitAliveOrValid(movableUnit))\n            {\n                ulong newCrowdID = ++UnitManager.crowdIDCounter;\n                movableUnit.ResetUnit(true);\n                movableUnit.SetAIModule(UnitAIModule.AIModule.BasicMovementAIModule, position, newCrowdID);\n            }\n        }\n    }\n}\n```\n\nOne thing to note. This is not completely done yet. A proper networking solution is yet to be done. This article could be updated time to time."
    },
    {
      "id": "my-fun-experiments-about-mimicking-aoe2-style-gameplay",
      "title": "Here's some of my fun experiment about mimicking some of the gamplay of Age Of Empires 2 style gameplay",
      "shortDescription": "This is short devlog for now but more to details will be updated soon",
      "contentMarkdown": "This is short devlog for now but more to details will be updated soon. Meanwhile here are some of my clips. I did here,\n\nSwordsman clashing each other. Bit buggy but works for now. Will need to think of better avoidance solution.\n<div style=\"position:relative; width:100%; height:0px; padding-bottom:52.072%\"><iframe allow=\"fullscreen\" allowfullscreen height=\"100%\" src=\"https://streamable.com/e/bca5pi?\" width=\"100%\" style=\"border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; overflow:hidden;\"></iframe></div>\n\nA large scale battle with archer support with new implemented projectile system support:\n<div style=\"position:relative; width:100%; height:0px; padding-bottom:52.083%\"><iframe allow=\"fullscreen\" allowfullscreen height=\"100%\" src=\"https://streamable.com/e/3nzntd?\" width=\"100%\" style=\"border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; overflow:hidden;\"></iframe></div>\n\nAlso added minor aim accuracy difference. Uses pure 3D physics:\n<div style=\"position:relative; width:100%; height:0px; padding-bottom:52.083%\"><iframe allow=\"fullscreen\" allowfullscreen height=\"100%\" src=\"https://streamable.com/e/dv20pn?\" width=\"100%\" style=\"border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; overflow:hidden;\"></iframe></div>"
    }
  ]
}